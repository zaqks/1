<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js - pointerlock controls</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
      }

      #instructions {
        width: 100%;
        height: 100%;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;

        text-align: center;
        font-size: 14px;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <p style="font-size: 36px">Click to play</p>
        <p>
          Move: WASD<br />
          Jump: SPACE<br />
          Look: MOUSE
        </p>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "../build/three.module.js",
          "three/addons/": "./jsm/"
        }
      }
    </script>

    <script type="module">
      import { PointerLockControls } from "https://cdn.skypack.dev/three@0.129.0/examples/jsm/controls/PointerLockControls.js";
      import * as THREE from "https://cdn.skypack.dev/three@0.129.0/build/three.module.js";

      let camera, scene, renderer, controls;

      const objects = [];

      let raycaster;

      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;

      let prevTime = performance.now();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const vertex = new THREE.Vector3();
      const color = new THREE.Color();

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
        camera.position.y = 10;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb); // Light blue sky background
        scene.fog = new THREE.Fog(0x87ceeb, 0, 750);

        const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 2.5);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);

        controls = new PointerLockControls(camera, document.body);

        const blocker = document.getElementById("blocker");
        const instructions = document.getElementById("instructions");

        instructions.addEventListener("click", function () {
          controls.lock();
        });

        controls.addEventListener("lock", function () {
          instructions.style.display = "none";
          blocker.style.display = "none";
        });

        controls.addEventListener("unlock", function () {
          blocker.style.display = "block";
          instructions.style.display = "";
        });

        scene.add(controls.getObject());

        const onKeyDown = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW":
              moveForward = true;
              break;
            case "ArrowLeft":
            case "KeyA":
              moveLeft = true;
              break;
            case "ArrowDown":
            case "KeyS":
              moveBackward = true;
              break;
            case "ArrowRight":
            case "KeyD":
              moveRight = true;
              break;
            case "Space":
              if (canJump === true) velocity.y += 350;
              canJump = false;
              break;
          }
        };

        const onKeyUp = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW":
              moveForward = false;
              break;
            case "ArrowLeft":
            case "KeyA":
              moveLeft = false;
              break;
            case "ArrowDown":
            case "KeyS":
              moveBackward = false;
              break;
            case "ArrowRight":
            case "KeyD":
              moveRight = false;
              break;
          }
        };

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        raycaster = new THREE.Raycaster(
          new THREE.Vector3(),
          new THREE.Vector3(0, -1, 0),
          0,
          10
        );

        // Floor
        const floorGeometry = new THREE.PlaneGeometry(2000, 2000);
        floorGeometry.rotateX(-Math.PI / 2);

        const floorMaterial = new THREE.MeshBasicMaterial({ color: 0x888888 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        scene.add(floor);

        // City buildings
        const buildingGeometry = new THREE.BoxGeometry(20, 20, 20);

        // Create 10 buildings with space between them
        const positions = [
          [-100, 0],
          [-70, 0],
          [-40, 0],
          [-10, 0],
          [20, 0],
          [50, 0],
          [80, 0],
          [110, 0],
          [140, 0],
          [170, 0],
        ];

        positions.forEach((pos) => {
          const buildingMaterial = new THREE.MeshPhongMaterial({
            color: new THREE.Color().setHSL(
              Math.random() * 0.2 + 0.5,
              0.75,
              Math.random() * 0.25 + 0.75
            ),
            flatShading: true,
          });

          const building = new THREE.Mesh(buildingGeometry, buildingMaterial);
          const height = Math.random() * 30 + 30; // More realistic building heights
          building.scale.y = height / 20;
          building.position.set(pos[0], height / 2, pos[1]);

          scene.add(building);
          objects.push(building);
        });

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        window.addEventListener("resize", onWindowResize);
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();

        if (controls.isLocked === true) {
          raycaster.ray.origin.copy(controls.getObject().position);
          raycaster.ray.origin.y -= 10;

          const intersections = raycaster.intersectObjects(objects, false);

          const onObject = intersections.length > 0;

          const delta = (time - prevTime) / 1000;

          velocity.x -= velocity.x * 10.0 * delta;
          velocity.z -= velocity.z * 10.0 * delta;

          velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

          direction.z = Number(moveForward) - Number(moveBackward);
          direction.x = Number(moveRight) - Number(moveLeft);
          direction.normalize(); // this ensures consistent movements in all directions

          if (moveForward || moveBackward)
            velocity.z -= direction.z * 400.0 * delta;
          if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

          if (onObject === true) {
            velocity.y = Math.max(0, velocity.y);
            canJump = true;
          }

          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);

          controls.getObject().position.y += velocity.y * delta; // new behavior

          if (controls.getObject().position.y < 10) {
            velocity.y = 0;
            controls.getObject().position.y = 10;

            canJump = true;
          }
        }

        prevTime = time;

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
